<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <link href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css" rel="stylesheet">
 <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <title>Interactive Plot</title>
    <style>
        .control-panel {
            margin-top: 20px;
        }
        #plot {
            margin-top: 30px;
        }
        .control-panel {
            margin-top: 30px;
        }

        .table-responsive {
            max-height: 300px;
            overflow-y: auto;
        }


        #dynamic-table thead th {
            position: sticky;
            top: 0;
            background-color: white;
            z-index: 1;
        }

        #dynamic-table td {
            height: 10px;
            vertical-align: middle;
        }


        #dynamic-table {
            table-layout: auto;
        }
    </style>
</head>
<body class="container mt-5">
    <label for="feature-select" class="mr-2">Select Feature:</label>
    <!-- Hier noch einfÃ¼gen, dass das erste numerische Feature angezeigt wird -->
    <select id="feature-select" class="form-control mr-2">
        <!-- Options will be dynamically populated -->
        {% for item in feature_names %}
        <option value="{{ item }}">{{ item }}</option>
        {% endfor %}
    </select>
    <div id="plot"></div>
    <div class="control-panel mt-4">
        <p><b>Adjust the shape function:</b></p>
        <form class="form-inline" style="margin-bottom: 20px;">
            <input type="number" class="form-control mr-2" style="width: 70px;" id="x1-value" placeholder="x1">
            <input type="number" class="form-control mr-2" style="width: 70px;" id="x2-value" placeholder="x2">
            <input type="number" class="form-control mr-2" style="width: 130px;" id="new-y-value" placeholder="new y-value">
            <button class="btn btn-primary mr-2" onclick="setConstantValue(); return false;">Set Constant Value</button>
            <button class="btn btn-primary mr-2" onclick="setlinear(); return false;">Set Linear</button>
            <button class="btn btn-info mr-2" onclick="setMonotonicIncrease(); return false;">Monotonic Increase</button>
            <button class="btn btn-info mr-2" onclick="setMonotonicDecrease(); return false;">Monotonic Decrease</button>
        </form>
        <p style="margin-bottom: 10px;"><b>Incorporate into model and predict:</b></p>
        <form class="form-inline">
            <button class="btn btn-success mr-2" onclick="predictAndGetMSE(); return false;">Get MSE</button>
            <div id="mse-output" class="btn btn-success mr-2" style="margin-right: 8px";>Calculating MSE...</div>
            <button class="btn btn-info mr-2" onclick="performCubicSplineInterpolation(); return false;">Cubic Spline Interpolation</button>
            <button class="btn btn-info mr-2" onclick="updateModel(); return false;">Update Model (Splines)</button>
            <button class="btn btn-info mr-2" onclick="updateWeights(); return false;">Update Model (Weights)</button>
        </form>
        <p style="margin-bottom: 10px;"><b>Restore:</b></p>
        <form class="form-inline" style="margin-bottom: 20px;">
            <button class="btn btn-danger" style="margin-right: 8px" onclick="resetGraph(); return false;">Reset</button>
            <button class="btn btn-secondary mr-2" onclick="undoLastChange(); return false;">Undo</button>
        </form>
    </div>
    <div class="table-responsive mt-4" style="overflow-x: auto; max-width: 100%;">
        <table id="dynamic-table" class="table table-bordered">
            <thead id="table-header">
            </thead>
            <tbody id="table-body">
            </tbody>
        </table>
    </div>





    <script>
        // Variables for creating the plot
        const plotData = [{
            x: {{ x_data|tojson }},
            y: {{ y_data|tojson }},
            mode: 'lines',
            type: 'scatter'
        }];

        const layout = {
            dragmode: 'select',
            autosize: true,
            responsive: true
        };
        let isNumericFeature = {{ is_numeric_feature|tojson }}; // Global variable to track feature type
        let selectedFeature = document.getElementById('feature-select').value;

        // Create the plot and store x1 and x2 values of bounding boxes
        Plotly.newPlot('plot', plotData, layout).then(() => {
            console.log("Plot created");
            store_x_values();
        });

        function store_x_values() {
            console.log("Calculating x values");
            document.getElementById('plot').on('plotly_selected', function(data) {
                if (!data) return;
                const x1 = data.range.x[0];
                const x2 = data.range.x[1];
                document.getElementById('x1-value').value = x1.toFixed(2);
                document.getElementById('x2-value').value = x2.toFixed(2);
            });
        };

        document.addEventListener('DOMContentLoaded', function() {
            const selectBox = document.getElementById('feature-select');
            // Event listener for feature selection change
            selectBox.addEventListener('change', function () {
                selectedFeature = selectBox.value;
                fetchFeatureData(selectedFeature);
            });
            predictAndGetMSE();
            //fetchFeatureData(selectBox.value);
        });

        function fetchFeatureData(selected_feature) {
            fetch('/feature_data', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({selected_feature: selected_feature}),
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('Error:', data.error);
                } else {
                    isNumericFeature = data.is_numeric;
                    let plotX = data.x;
                    let plotY = data.y;

                    if (!isNumericFeature) {
                        layout.xaxis = {
                            tickvals: plotX,
                            ticktext: data.original_values
                        };
                        Plotly.newPlot('plot', [{
                            x: plotX,
                            y: plotY,
                            type: 'bar'
                        }], layout);
                    } else {
                        Plotly.newPlot('plot', [{
                            x: plotX,
                            y: plotY,
                            type: 'scatter',
                            mode: 'lines'
                        }], layout);
                    }

                    store_x_values();
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
        }

        function setConstantValue() {
            const x1 = parseFloat(document.getElementById('x1-value').value);
            const x2 = parseFloat(document.getElementById('x2-value').value);
            const newYValue = parseFloat(document.getElementById('new-y-value').value);

            fetch('/setConstantValue', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({x1: x1, x2: x2, new_y: newYValue, selected_feature: selectedFeature})
            })
            .then(response => response.json())
            .then(data => {
                Plotly.update('plot', {y: [data.y]});
            });
        }

        function setMonotonicIncrease() {
            const x1 = parseFloat(document.getElementById('x1-value').value);
            const x2 = parseFloat(document.getElementById('x2-value').value);

            fetch('/monotonic_increase', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({x1: x1, x2: x2, selected_feature: selectedFeature})
            })
            .then(response => response.json())
            .then(data => {
                Plotly.update('plot', {y: [data.y]});
            });
        }

        function setMonotonicDecrease() {
            const x1 = parseFloat(document.getElementById('x1-value').value);
            const x2 = parseFloat(document.getElementById('x2-value').value);

            fetch('/monotonic_decrease', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({x1: x1, x2: x2, selected_feature: selectedFeature})
            })
            .then(response => response.json())
            .then(data => {
                Plotly.update('plot', {y: [data.y]});
            });
        }

        function performCubicSplineInterpolation() {
            const selectedFeature = document.getElementById('feature-select').value;

            fetch('/cubic_spline_interpolate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ selected_feature: selectedFeature })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error occurred: ' + data.error);
                } else {
                    // If the spline interpolation was successful, add the new trace to the plot
                    var newTrace = {
                        x: data.x,
                        y: data.y,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Spline'
                    };

                    Plotly.addTraces('plot', newTrace);
                }
            })
        }

        function updateWeights() {
            const selectedFeature = document.getElementById('feature-select').value;
            console.log("that worked")
            fetch('/update_weights', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({selected_feature: selectedFeature})
            })
            .then(response => response.json())
            .then(data => {
                Plotly.update('plot', {y: [data.y]});
            });
        }


        function predictAndGetMSE() {
            fetch('/predict_and_get_mse')
            .then(response => response.json())
            .then(data => {
                // Create the MSE output content
                let mseOutputContent = 'Mean Squared Error on Training Set: ' + data.mse_train.toFixed(2) +
                                       '<br>Mean Squared Error on Validation Set: ' + data.mse_val.toFixed(2);

                // Set the content to the mse-output div and show it
                let mseOutputDiv = document.getElementById('mse-output');
                mseOutputDiv.innerHTML = mseOutputContent;
                mseOutputDiv.style.display = 'block';
            })
            .catch(error => {
                // If there's an error, display it in the mse-output div
                let mseOutputDiv = document.getElementById('mse-output');
                mseOutputDiv.className = 'alert alert-danger';
                mseOutputDiv.innerHTML = 'Error: ' + error;
                mseOutputDiv.style.display = 'block';
            });
        }

        function resetGraph() {
            fetch('/get_original_data', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({selected_feature: selectedFeature})
            })
            .then(response => response.json())
            .then(data => {
                Plotly.update('plot', {x: [data.x], y: [data.y]});
            });
        }

        function undoLastChange() {
            fetch('/undo_last_change', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({selected_feature: selectedFeature})
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(data.error);
                } else {
                    Plotly.update('plot', {y: [data.y]});
                }
            });
        }

        function updateModel() {
            fetch('/update_model', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({selected_feature: selectedFeature})
            })
            .then(response => response.json())
            .then(data => {
                // Create the MSE output content
                let mseOutputContent = 'Mean Squared Error on Training Set: ' + data.mse_train.toFixed(2) +
                                       '<br>Mean Squared Error on Testing Set: ' + data.mse_test.toFixed(2);

                // Set the content to the mse-output div and show it
                let mseOutputDiv = document.getElementById('mse-output');
                mseOutputDiv.innerHTML = mseOutputContent;
                mseOutputDiv.style.display = 'block';
            })
        }
        function updateTable() {
            fetch('/load_data_grid_instances', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                // TODO: replace initial by a variable
                body: JSON.stringify({type_of_data: 'initial'})
            })
                .then(response => response.json())
                .then(data => {
                    createTableHeader(data.columns);
                    populateTableBody(data.rows);
                })
                .catch(error => console.error('Error:', error));
        }

        function createTableHeader(columns) {
            const thead = document.getElementById('table-header');
            thead.innerHTML = ''; // Clear existing header

            const tr = document.createElement('tr');
            columns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col;
                tr.appendChild(th);
            });
            thead.appendChild(tr);
        }

        function populateTableBody(rows) {
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = ''; // Clear existing rows

            rows.forEach(row => {
                const tr = document.createElement('tr');
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
        }

// Call this function to initialize the table
updateTable();


    </script>
</body>
</html>